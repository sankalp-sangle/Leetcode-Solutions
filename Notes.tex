\documentclass[11pt]{book}    

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
}

\parindent0pt  \parskip10pt             % make block paragraphs
\raggedright                            % do not right justify

\title{\bf LeetCode Solutions}    % Supply information
\author{Sankalp Sangle}              %   for the title page.
\date{Last updated on \today}                           %   Use current date. 

% Note that book class by default is formatted to be printed back-to-back.
\begin{document}                        % End of preamble, start of text.
\frontmatter                            % only in book class (roman page #s)
\maketitle                              % Print title page.
\tableofcontents                        % Print table of contents
\mainmatter                             % only in book class (arabic page #s)

\part{LeetCode Top Interview Questions}                   % Print a "part" heading

\chapter{Easy}                % Print a "chapter" heading
Link: \href{https://leetcode.com/explore/interview/card/top-interview-questions-easy/}{LeetCode Top Interview Questions: Easy section}. 

\section{Arrays}                  % Print a "section" heading
Link: \href{https://leetcode.com/explore/interview/card/top-interview-questions-easy/92/array/}{Arrays}

\subsection{26. Remove Duplicates from Sorted Array}
\href{https://leetcode.com/problems/remove-duplicates-from-sorted-array/}{Link to question},
\href{https://leetcode.com/submissions/detail/332869256/}{Link to submission}
\paragraph{Concepts}
Two pointer
\paragraph{Algorithm description}
\begin{itemize}
    \item Maintain a read pointer and a write pointer, both starting from zero.
    \item Advance the write pointer until you see a new value or reach end of array.
    \item Write value at write location into read location.
    \item Return read.
\end{itemize}

\subsection{122. Best Time to Buy and Sell Stock II}
\href{https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/}{Link to question},
\href{https://leetcode.com/submissions/detail/332894775/}{Link to submission}
\paragraph{Concepts} Greedy

\paragraph{Algorithm description}
\begin{itemize}
    \item Construct a consecutive elements difference array
    \item Return sum of all positive elements in difference array
\end{itemize}

\subsection{189. Rotate Array}
\href{https://leetcode.com/problems/rotate-array/}{Link to question},
\href{https://leetcode.com/submissions/detail/333064713/}{Link to submission approach 1},
\href{https://leetcode.com/submissions/detail/333059899/}{Link to submission approach 2}
\paragraph{Concepts}
Cyclic replacements, Implementation
\paragraph{Approach 1 description}
\begin{itemize}
    \item Maintain a visited array and a pointer initialized to 0
    \item while pointer + k is not visited, replace arr[pointer + k] with arr[pointer]. Update
    pointer to pointer + k. Set pointer + k to visited, increment a numberOfChanges variable.
    \item Increment pointer by 1
    \item Keep doing this while numberOfChanges less than size of array.
\end{itemize}
\paragraph{Approach 2 description}
\begin{itemize}
    \item Reverse the entire array
    \item Reverse from start to start + k
    \item Reverse from start + k to end
\end{itemize}

\subsection{217. Contains Duplicate}
\href{https://leetcode.com/problems/contains-duplicate/}{Link to question},
\href{https://leetcode.com/submissions/detail/333069819/}{Link to submission}
\paragraph{Concepts}
Hash Table, Set
\paragraph{Algorithm description}
\begin{itemize}
    \item Initialize a Set
    \item For an element in array, if element in Set, return true
    \item else add element to Set
    \item If out of loop, return False
\end{itemize}
 
\subsection{136. Single Number}
\href{https://leetcode.com/problems/single-number/}{Link to question},
\href{https://leetcode.com/submissions/detail/333115980/}{Link to submission}
\paragraph{Concepts}
Bit Manipulation, XOR
\paragraph{Algorithm description}
\begin{itemize}
    \item Initialize an answer variable to 0
    \item For every element, XOR it to answer. Elements appearing twice get XOR'd out to zero
    \item Return answer
\end{itemize}

\subsection{350. Intersection of Two Arrays II}
\href{https://leetcode.com/problems/intersection-of-two-arrays-ii/}{Link to question},
\href{https://leetcode.com/submissions/detail/333119654/}{Link to submission approach 1},
\href{https://leetcode.com/submissions/detail/333123474/}{Link to submission approach 2}
\paragraph{Concepts}
Hash Table, Two Pointers
\paragraph{Approach 1 description}
\begin{itemize}
    \item Form an element:frequency mapping using map for smaller array (to save space)
    \item Traverse bigger array
    \item If frequency of element less than 0, add to answer. Decrement frequency
\end{itemize}
\paragraph{Approach 2 description}
\begin{itemize}
    \item If arrays are sorted, use two pointers p1 and p2
    \item If nums1[p1] == nums2[p2], add to answer and increment both
    \item Else if nums1[p1] is smaller, increment p1. Else increment p2
    \item Keep doing until reach end of either array
\end{itemize}

\subsection{66. Plus One}
\href{https://leetcode.com/problems/plus-one/}{Link to question},
\href{https://leetcode.com/submissions/detail/333134799/}{Link to submission}
\paragraph{Concepts}
Array
\paragraph{Algorithm description}
\begin{itemize}
    \item Initialize a carry variable to 1
    \item Traverse array from the end. \\ digit[i] = carry + digit mod 10, carry = carry + digit div 10
    \item Finally, if carry is not zero, insert carry at start of array
\end{itemize}

\subsection{283. Move Zeroes}
\href{https://leetcode.com/problems/move-zeroes/}{Link to question},
\href{https://leetcode.com/submissions/detail/333138944/}{Link to submission}
\paragraph{Concepts}
Two Pointers
\paragraph{Algorithm description}
\begin{itemize}
    \item Maintain a read and a write pointer, both initialized to 0
    \item if read end has zero, increment read end
    \item else, copy read end to write end and increment both
    \item After read end reaches end, set all numbers from write end to end as 0
\end{itemize}

\subsection{1. Two Sum}
\href{https://leetcode.com/problems/two-sum/}{Link to question},
\href{https://leetcode.com/submissions/detail/333142473/}{Link to submission approach 1},
\href{https://leetcode.com/submissions/detail/333144602/}{Link to submission approach 2}
\paragraph{Concepts}
Hash Table, Two Pointer
\paragraph{Approach 1 description}
\begin{itemize}
    \item Create an element:indices mapping
    \item Sort the array
    \item Use two pointers to search for a particular sum
    \item Once you find the sum, pop index from left pointer, and pop index from right pointer
    \item Return indices
\end{itemize}
\paragraph{Approach 2 description}
\begin{itemize}
    \item Create a hashmap of int, int
    \item Iterate the array with i as looping variable
    \item If element in hashmap, return (hashmap[element], i)
    \item Else insert hashmap[target - element] = i
\end{itemize}

\subsection{36. Valid Sudoku}
\href{https://leetcode.com/problems/valid-sudoku/}{Link to question},
\href{https://leetcode.com/submissions/detail/333176948/}{Link to submission}
\paragraph{Concepts}
Hash Table, Set
\paragraph{Algorithm description}
\begin{itemize}
    \item Create sets to hold numbers for each row, col and square.
    \item Traverse the sudoku
    \item If a number is already in the row, col, square, return False
    \item Else, come out of loop and return true
\end{itemize}

\subsection{48. Rotate Image}
\href{https://leetcode.com/problems/rotate-image/}{Link to question},
\href{https://leetcode.com/submissions/detail/333188499/}{Link to submission}
\paragraph{Concepts}
Array, Circular Permutation, Implementation Heavy
\paragraph{Algorithm description}
\begin{itemize}
    \item Do a counterclockwise circular permutation as mentioned in solution
    \item Pure implementation problem. No algorithmic skill.
\end{itemize}

\newpage

\section{Strings}
Link: \href{https://leetcode.com/explore/interview/card/top-interview-questions-easy/127/strings/}{Strings}

\subsection{344. Reverse String}
\href{https://leetcode.com/problems/reverse-string/}{Link to question},
\href{https://leetcode.com/submissions/detail/333295707/}{Link to submission}
\paragraph{Concepts}
Two Pointers
\paragraph{Algorithm description}
\begin{itemize}
    \item Set a left pointer to start of string, right pointer to end
    \item Swap left and right. Increment left, decrement right
    \item Do while l less than r
\end{itemize}

\subsection{7. Reverse Integer}
\href{https://leetcode.com/problems/reverse-integer/}{Link to question},
\href{https://leetcode.com/submissions/detail/333300400/}{Link to submission}
\paragraph{Concepts}
Two Pointers
\paragraph{Algorithm description}
\begin{itemize}
    \item Reverse the integer by converting to a string
    \item Store result in long
    \item If stored result is outside integer limits, return 0
    \item Else return the reversed number
\end{itemize}

\subsection{387. First Unique Character in a String}
\href{https://leetcode.com/problems/first-unique-character-in-a-string/}{Link to question},
\href{https://leetcode.com/submissions/detail/333317093/}{Link to submission}
\paragraph{Concepts}
Hash Map
\paragraph{Algorithm description}
\begin{itemize}
    \item Construct element frequency mapping
    \item Traverse the string from the start, if frequency of a char is 1, return index
    \item If reach end of string, return -1
\end{itemize}

\subsection{242. Valid Anagram}
\href{https://leetcode.com/problems/valid-anagram/}{Link to question},
\href{https://leetcode.com/submissions/detail/333323752/}{Link to submission}
\paragraph{Concepts}
Hash Map, Counting Sort
\paragraph{Algorithm description}
\begin{itemize}
    \item Traverse through s1, incrementing frequency counts
    \item Traverse through s2, decrementing frequency counts
    \item If all counts are zero, return true. Else false.
\end{itemize}

\subsection{125. Valid Palindrome}
\href{https://leetcode.com/problems/valid-palindrome/}{Link to question},
\href{https://leetcode.com/submissions/detail/333333971/}{Link to submission}
\paragraph{Concepts}
Two Pointers
\paragraph{Algorithm description}
\begin{itemize}
    \item Maintain a left and a right pointer
    \item Before comparing the two, ensure left and right both are pointing to an
    alphanumeric character
\end{itemize}

\subsection{28. Implement strStr()}
\href{https://leetcode.com/problems/implement-strstr/}{Link to question},
\href{https://leetcode.com/submissions/detail/333634575/}{Link to Approach 1},
\href{https://leetcode.com/submissions/detail/333729270/}{Link to Approach 2}
\paragraph{Concepts}
Two Pointers, Rabin-Karp Algorithm, Rolling Hash
\paragraph{Approach 1 description}
\begin{itemize}
    \item Traverse haystack until you find a character matching with first character of
    needle
    \item Once match is found, keep checking for further characters 
    until either there's a mismatch or you reach end of arrays
    \item Return index accordingly
\end{itemize}
\paragraph{Approach 2 description - Rabin-Karp}
\begin{itemize}
    \item Hash the needle using a hash function that is easy to be "rolled", that is it is
    easy to compute hash for next window if hash for previous window is known
    \item Traverse the haystack using window of length needle.length(). Hash the window and 
    compare with needle hash. If matched, return the index of start of window
    \item See implementation carefully, very interesting. Also see LeetCode solution article.
\end{itemize}

\subsection{38. Count and Say}
\href{https://leetcode.com/problems/count-and-say/}{Link to question},
\href{https://leetcode.com/submissions/detail/333834219/}{Link to submission}
\paragraph{Concepts}
Recursion, Two Pointers
\paragraph{Algorithm description}
\begin{itemize}
    \item Base case: n = 1, return "1"
    \item Get the answer for n-1
    \item Traverse through answer of n-1
    \item For each consecutive list of same elements, add the count, followed by the element
    \item Return answer
\end{itemize}

\subsection{14. Longest Common Prefix}
\href{https://leetcode.com/problems/longest-common-prefix/}{Link to question},
\href{https://leetcode.com/submissions/detail/333844730/}{Link to submission}
\paragraph{Concepts}
Implementation
\paragraph{Algorithm description}
\begin{itemize}
    \item Initialize answer string to ""
    \item Find length of smallest string
    \item For i from 0 to min length - 1
    \item Traverse through all the characters at ith positions
    \item If different, return answer
    \item If same, add character to answer
\end{itemize}

\newpage

\section{Linked Lists}
Link: \href{https://leetcode.com/explore/interview/card/top-interview-questions-easy/93/linked-list/}{Linked Lists}

\subsection{237. Delete Node in a Linked List}
\href{https://leetcode.com/problems/delete-node-in-a-linked-list/}{Link to question},
\href{https://leetcode.com/submissions/detail/333854173/}{Link to submission}
\paragraph{Concepts}
Trick
\paragraph{Algorithm description}
\begin{itemize}
    \item Copy value of next node into current node
    \item Set next ptr of current node to next ptr of next node
\end{itemize}

\subsection{19. Remove Nth Node From End of List}
\href{https://leetcode.com/problems/remove-nth-node-from-end-of-list/}{Link to question},
\href{https://leetcode.com/submissions/detail/333863765/}{Link to submission}
\paragraph{Concepts}
Two Pointer
\paragraph{Algorithm description}
\begin{itemize}
    \item To do it in one pass, let a forward pointer advance n steps
    \item Then, start forwarding a slow pointer as well as the forward pointer one at a time
          until forward reaches the end
    \item delete the slow pointer node
\end{itemize}

\subsection{206. Reverse Linked List}
\href{https://leetcode.com/problems/reverse-linked-list/}{Link to question},
\href{https://leetcode.com/submissions/detail/333870150/}{Link to iterative approach},
\href{https://leetcode.com/submissions/detail/333909164/}{Link to recursive approach}
\paragraph{Concepts}
Implementation
\paragraph{Approach 1 description}
\begin{itemize}
    \item Initialize a prev = NULL, and a curr = head
    \item While head is not NULL, do a cyclic swap between curr.next, prev, and curr.
    \item Return prev
\end{itemize}
\paragraph{Approach 2 description}
\begin{itemize}
    \item If head is NULL or head.next is NULL return head
    \item l = reversed list for head.next
    \item head.next.next = head, head.next = NULL. Return l
\end{itemize}

\subsection{21. Merge Two Sorted Lists}
\href{https://leetcode.com/problems/merge-two-sorted-lists/}{Link to question},
\href{https://leetcode.com/submissions/detail/334181938/}{Link to iterative submission},
\href{https://leetcode.com/submissions/detail/334165928/}{Link to recursive submission}
\paragraph{Concepts}
Two Pointers
\paragraph{Algorithm description Iterative}
\begin{itemize}
    \item Make a dummy node, and let tmp = dummynode
    \item Keep appending the smaller of the two lists to the dummy node and advance the pointers
        accordingly
    \item If one of the lists becomes NULL, append the other list to dummy node
    \item Return next of tmp
\end{itemize}
\paragraph{Algorithm description Recursive}
\begin{itemize}
    \item If either of lists is NULL, return the other
    \item if l1 is smaller, get answer to (l1.next, l2) and set it as l1.next. Return l1
    \item Else get answer to (l1, l2.next) and set it as l2.next. Return l2
\end{itemize}

\subsection{234. Palindrome Linked List}
\href{https://leetcode.com/problems/palindrome-linked-list/}{Link to question},
\href{https://leetcode.com/submissions/detail/334192848/}{Link to submission}
\paragraph{Concepts}
Reverse a linked list, Two Pointers
\paragraph{Algorithm description}
\begin{itemize}
    \item Reverse the second half of the linked list
    \item Compare nodewise the head of linked list and the head of reversed list
        to check for palindrome
\end{itemize}

\subsection{141. Linked List Cycle}
\href{https://leetcode.com/problems/linked-list-cycle/}{Link to question},
\href{https://leetcode.com/submissions/detail/334195990/}{Link to submission}
\paragraph{Concepts}
Hare and Tortoise, Two Pointers
\paragraph{Algorithm description}
\begin{itemize}
    \item Initialize a slow and a fast pointer
    \item Advance slow by 1, fast by 2
    \item If slow and fast meet, there's a cycle. Else if fast reaches end, there's no cycle.
\end{itemize}

\newpage

\section{Trees}
Link: \href{https://leetcode.com/explore/interview/card/top-interview-questions-easy/94/trees/}{Trees}

\subsection{104. Maximum Depth of Binary Tree}
\href{https://leetcode.com/problems/maximum-depth-of-binary-tree/}{Link to question},
\href{https://leetcode.com/submissions/detail/334227706/}{Link to recursive submission},
\href{https://leetcode.com/submissions/detail/334260483/}{Link to iterative submission}
\paragraph{Concepts}
Recursion, Stack
\paragraph{Algorithm description Recursive}
\begin{itemize}
    \item If root is null, return 0
    \item Else return 1 + max(maxDepth(left), maxDepth(right))
\end{itemize}
\paragraph{Algorithm description Iterative}
\begin{itemize}
    \item If root is null, return 0
    \item Initialize stack holding pair of TreeNode and depth
    \item Push \{root, 1\}
    \item While stack is not empty, get top of stack
    \item If top is leaf, compare with maxDepth
    \item Push children if any with depth = 1 + parent depth
\end{itemize}

\subsection{98. Validate Binary Search Tree}
\href{https://leetcode.com/problems/validate-binary-search-tree/}{Link to question},
\href{https://leetcode.com/submissions/detail/334300642/}{Link to iterative submission},
\href{https://leetcode.com/submissions/detail/334297136/}{Link to recursive submission}
\paragraph{Concepts}
Top-Down
\paragraph{Algorithm description (for recursive/iterative)}
\begin{itemize}
    \item Approach is a top-down one
    \item At every node, check if node.val is between a range of [small, large]
    \item If not, return False
    \item else check left subtree for range[small, node.val] and check right subtree for range[node.val, large]
    \item Return the AND of the above two
\end{itemize}

\subsection{101. Symmetric Tree}
\href{https://leetcode.com/problems/symmetric-tree/}{Link to question},
\href{https://leetcode.com/submissions/detail/335199504/}{Link to recursive submission},
\href{https://leetcode.com/submissions/detail/335199304/}{Link to iterative submission}
\paragraph{Concepts}
Top-Down
\paragraph{Algorithm description (for recursive/iterative)}
\begin{itemize}
    \item Top down approach
    \item Check if leftTree.val == rightTree.val
    \item If true, check for leftTree.left, rightTree.right and leftTree.right, rightTree.left
    \item Else, return False
\end{itemize}

\subsection{102. Binary Tree Level Order Traversal}
\href{https://leetcode.com/problems/binary-tree-level-order-traversal/}{Link to question},
\href{https://leetcode.com/submissions/detail/335213120/}{Link to submission}
\paragraph{Concepts}
Top-Down, BFS
\paragraph{Algorithm description}
\begin{itemize}
    \item Push root into a queue
    \item At beginning of an iteration, take size of queue
    \item Pop out \#size items from queue, while adding their children to queue
    \item Add to level
    \item Add level to final answer
\end{itemize}

\subsection{108. Convert Sorted Array to Binary Search Tree}
\href{https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/}{Link to question},
\href{https://leetcode.com/submissions/detail/335241263/}{Link to submission}
\paragraph{Concepts}
Recursion, Preorder
\paragraph{Algorithm description}
\begin{itemize}
    \item call procedure with left = 0, right = arr.size() - 1
    \item if left greater than right, return NULL
    \item construct node for middle element
    \item node.left = procedure(left, middle-1), node.right = procedure(middle+1, right)
    \item return node
\end{itemize}

\newpage

\section{Sorting and Searching}
Link: \href{https://leetcode.com/explore/featured/card/top-interview-questions-easy/96/sorting-and-searching/}{Sorting and Searching}

\subsection{88. Merge Sorted Array}
\href{https://leetcode.com/problems/merge-sorted-array/}{Link to question},
\href{https://leetcode.com/submissions/detail/335252401/}{Link to submission}
\paragraph{Concepts}
Two Pointers
\paragraph{Algorithm description}
\begin{itemize}
    \item Create a copy array for nums1
    \item Maintain write pointer for nums1, p1 for nums1copy, p2 for nums2
    \item Write smaller of p1, p2 into nums1. Advance smaller and write head.
    \item Once out of the loop, see which array still has elements remaining. Add them to nums1
\end{itemize}

\subsection{278. First Bad Version}
\href{https://leetcode.com/problems/first-bad-version/}{Link to question},
\href{https://leetcode.com/submissions/detail/335254058/}{Link to submission}
\paragraph{Concepts}
Binary Search
\paragraph{Algorithm description}
\begin{itemize}
    \item set left as 0, right as n - 1
    \item while l less than equal to r
    \item if mid is bad, right = middle - 1
    \item else left = middle + 1
    \item Once you come out of loop, return l
\end{itemize}

\newpage

\section{Dynamic Programming}
Link: \href{https://leetcode.com/explore/featured/card/top-interview-questions-easy/97/dynamic-programming/569/}{Dynamic Programming}

\subsection{70. Climbing Stairs}
\href{https://leetcode.com/problems/climbing-stairs/}{Link to question},
\href{https://leetcode.com/submissions/detail/335398986/}{Link to submission}
\paragraph{Concepts}
Dynamic Programming
\paragraph{Algorithm description}
\begin{itemize}
    \item Ways to reach ith step = ways to reach i-1 th step plus ways to reach i-2 th step
\end{itemize}

\subsection{121. Best Time to Buy and Sell Stock}
\href{https://leetcode.com/problems/best-time-to-buy-and-sell-stock/}{Link to question},
\href{https://leetcode.com/submissions/detail/335403058/}{Link to submission}
\paragraph{Concepts}
Dynamic Programming
\paragraph{Algorithm description}
\begin{itemize}
    \item Maintain a smallest stock price seen yet variable
    \item Update maxProfit = max(maxProfit, current price - maxProfit)
\end{itemize}

\subsection{53. Maximum Subarray}
\href{https://leetcode.com/problems/maximum-subarray/}{Link to question},
\href{https://leetcode.com/submissions/detail/335407441/}{Link to submission}
\paragraph{Concepts}
Dynamic Programming
\paragraph{Algorithm description}
\begin{itemize}
    \item Maintain a current sum variable, denoting the highest sum possible that contains the element at the index
    \item Maintain a highest sum variable, denoting the highest sum encountered among the current sums
\end{itemize}

\subsection{198. House Robber}
\href{https://leetcode.com/problems/house-robber/}{Link to question},
\href{https://leetcode.com/submissions/detail/335418653/}{Link to submission},
\href{https://leetcode.com/submissions/detail/335415699/}{Link to submission (space optimized)}
\paragraph{Concepts}
Dynamic Programming
\paragraph{Algorithm description}
\begin{itemize}
    \item Maintain a dp array with dp[0] = nums[0], dp[1] = max(nums[0], nums[1]).
    dp[i] denotes maximum amount that can be robbed with first i+1 houses
    \item dp[i] = max(dp[i-1], dp[i-2] + nums[i])
    \item Finally return dp[n-1]
\end{itemize}

\newpage

\section{Design}
Link: \href{https://leetcode.com/explore/featured/card/top-interview-questions-easy/98/design/}{Design}

\subsection{384. Shuffle an Array}
\href{https://leetcode.com/problems/shuffle-an-array/}{Link to question},
\href{https://leetcode.com/submissions/detail/335673163/}{Link to submission}
\paragraph{Concepts}
Fisher-Yates Algorithm, Random Permutation
\paragraph{Algorithm description}
\begin{itemize}
    \item Iterate through the array
    \item For every iteration, generate an index between [current index, last index]
    \item Swap elements at current index and generated index
    \item Return array
\end{itemize}

\subsection{155. Min Stack}
\href{https://leetcode.com/problems/min-stack/}{Link to question},
\href{https://leetcode.com/submissions/detail/335680451/}{Link to submission}
\paragraph{Concepts}
Two stacks
\paragraph{Algorithm description}
\begin{itemize}
    \item Use one stack to keep track of all elements, and another minstack to keep track of minimums
    \item Push(x): push x to stack. Push x to minstack only if x less than or equal to top of minstack or if minstack is empty
    \item Pop(): pop from stack. Pop from minstack if stack.top() == minstack.top()
    \item getMin(): return minstack.top()
\end{itemize}

\newpage

\section{Math}
Link: \href{https://leetcode.com/explore/featured/card/top-interview-questions-easy/102/math/}{Math}

\subsection{412. Fizz Buzz}
\href{https://leetcode.com/problems/fizz-buzz/}{Link to question},
\href{https://leetcode.com/submissions/detail/335686182/}{Link to submission 1},
\href{https://leetcode.com/submissions/detail/335700407/}{Link to submission 2 (Easier to maintain)}
\paragraph{Concepts}
Divisibility
\paragraph{Algorithm description}
\begin{itemize}
    \item Instead of following naive approach of check divisibility by 15 first, then by 3 and 5, use an incremental approach
    \item Add "Fizz" to answer if divisible by 3
    \item Add "Buzz" to answer if divisible by 5
    \item This code is much easier to maintain if more conditions like 7:"Jazz" are added. Also note submission 2, which is
        even easier to maintain
\end{itemize}

\subsection{204. Count Primes}
\href{https://leetcode.com/problems/count-primes/}{Link to question},
\href{https://leetcode.com/submissions/detail/335711052/}{Link to submission}
\paragraph{Concepts}
Number Theory, Math, Primes
\paragraph{Algorithm description}
\begin{itemize}
    \item Let's start with a isPrime function. To determine if a number is prime, we need to check if it is not divisible by any number less than n. The runtime complexity of isPrime function would be O(n) and hence counting the total prime numbers up to n would be O(n2). Could we do better?
    \item As we know the number must not be divisible by any number greater than n / 2, we can immediately cut the total iterations half by dividing only up to n / 2. Could we still do better?
    \item We don't need to go all the way till n / 2. Just stopping at sqrt(n) is enough. Complexity is now O(n to the power 1.5)
    \item Notice that if we've tested for the number x being prime, we don't need to test for multiples of x being prime anymore.
    This is the motivation for the Sieve of Eratosthenes. Take a number, if it is not visited, mark all it's multiples excluding itself as visited. Increment number and repeat.
    \item One optimization is to not start at 2x but to start at x times x, as 2x had already been marked when marking multiples of two.
    \item Finally, there is no need to go through all numbers till n. We only need to do the sieve for numbers till root of n.
    \item Answer is count of unvisited elements in visited array
    \item Definitely look through the final submission for all the optimizations.
    \item Complexity - O(n log log n)
\end{itemize}

\subsection{326. Power of Three}
\href{https://leetcode.com/problems/power-of-three/solution/}{Link to question},
\href{https://leetcode.com/submissions/detail/335722204/}{Link to submission}
\paragraph{Concepts}
Math
\paragraph{Algorithm description}
\begin{itemize}
    \item Since they're asking for no loops/recursion (which would be the naive approach), the idea is to find the largest power of 3 that fits in 4 byte size
    \item If (largest number which is power of 3) \% num == 0, then number is a power of 3
    \item Bear in mind that this will only work for powers of x where x is a prime number.
    \item Do look at editorial for a good discussion on logarithms approach as well.
\end{itemize}

\subsection{13. Roman to Integer}
\href{https://leetcode.com/problems/roman-to-integer/}{Link to question},
\href{https://leetcode.com/submissions/detail/335726047/}{Link to submission}
\paragraph{Concepts}
Parsing
\paragraph{Algorithm description}
\begin{itemize}
    \item Maintain two pointers, current and next, initialized to 0 and 1
    \item If value at curr greater than equal value at next, add value at curr to answer. Increment both pointers
    \item Else, add value at next to answer, subtract value at curr to answer, increment both pointers by two.
    \item Once out of loop, if curr less than string.length(), add value at curr to answer
    \item Return answer
    \item Note: this is a left to right pass solution. Also see the right to left pass submission shown in the editorial
\end{itemize}

\newpage

\section{Others}
Link: \href{https://leetcode.com/explore/featured/card/top-interview-questions-easy/99/others/}{Others}

\subsection{191. Number of 1 Bits}
\href{https://leetcode.com/problems/number-of-1-bits/}{Link to question},
\href{https://leetcode.com/submissions/detail/335731817/}{Link to submission}
\paragraph{Concepts}
Bit Manipulation
\paragraph{Algorithm description}
\begin{itemize}
    \item initialize answer to 0
    \item While number not equal to 0, set number as (number \& number-1), increment answer
    \item return answer
\end{itemize}

\subsection{461. Hamming Distance}
\href{https://leetcode.com/problems/hamming-distance/}{Link to question},
\href{https://leetcode.com/submissions/detail/335742515/}{Link to submission}
\paragraph{Concepts}
Bit Manipulation
\paragraph{Algorithm description}
\begin{itemize}
    \item Let A be xor of x and y (xor returns a 1 if the operands are different)
    \item Count number of set bits in A
\end{itemize}

\subsection{190. Reverse Bits}
\href{https://leetcode.com/problems/reverse-bits/}{Link to question},
\href{https://leetcode.com/submissions/detail/335782937/}{Link to submission 1 (naive)},
\href{https://leetcode.com/submissions/detail/323297368/}{Link to submission 2 (constant time)}
\paragraph{Concepts}
Bit Manipulation
\paragraph{Algorithm description}
\begin{itemize}
    \item Naive solution is clear, compare bits at opposite ends. If different, flip them
    \item For constant time, first, we break the original 32-bit into 2 blocks of 16 bits, and switch them. 
    \item We then break the 16-bits block into 2 blocks of 8 bits. Similarly, we switch the position of the 8-bits blocks 
    \item We then continue to break the blocks into smaller blocks, until we reach the level with the block of 1 bit. 
\end{itemize}

\subsection{118. Pascal's Triangle}
\href{https://leetcode.com/problems/pascals-triangle/}{Link to question},
\href{https://leetcode.com/submissions/detail/335834624/}{Link to submission}
\paragraph{Concepts}
Implementation
\paragraph{Algorithm description}
\begin{itemize}
    \item Nothing fancy, just construct row by row as mentioned in the description.
\end{itemize}

\subsection{20. Valid Parentheses}
\href{https://leetcode.com/problems/valid-parentheses/}{Link to question},
\href{https://leetcode.com/submissions/detail/335853123/}{Link to submission}
\paragraph{Concepts}
Stack
\paragraph{Algorithm description}
\begin{itemize}
    \item Iterate through string
    \item If it's an opening bracket, push onto stack
    \item Else, if it's not a matching bracket, return False
    \item If matching bracket, pop from stack
    \item When you come out of loop, if stack is empty return true
    \item Return false
\end{itemize}

\subsection{268. Missing Number}
\href{https://leetcode.com/problems/missing-number/}{Link to question},
\href{https://leetcode.com/submissions/detail/335861817/}{Link to submission}
\paragraph{Concepts}
Bit Manipulation
\paragraph{Algorithm description}
\begin{itemize}
    \item XOR all numbers in the range [0,n] into a variable answer
    \item Iterate through the array, XORing every element into the answer variable
    \item Return answer. All elements will have appeared twice, except the missing number
    which appeared once, and hence is stored in answer variable 
\end{itemize}

\chapter{Medium}
Link: \href{https://leetcode.com/explore/interview/card/top-interview-questions-medium/}{LeetCode Top Interview Questions: Medium section}.

\section{Array and Strings}
Link: \href{https://leetcode.com/explore/interview/card/top-interview-questions-medium/103/array-and-strings/}{Array and Strings}

\subsection{15. 3Sum}
\href{https://leetcode.com/problems/3sum/}{Link to question},
\href{https://leetcode.com/submissions/detail/335882786/}{Link to submission}
\paragraph{Concepts}
Two Pointer, Sorting
\paragraph{Algorithm description}
\begin{itemize}
    \item Sort the array
    \item Traverse from left. For each iteration, fix target as -1 * nums[i]
    \item Maintain left ptr as i+1, and right ptr as end of arrays
    \item Search if sum of values at left and right equals target
    \item If so, add triplet to answer. Move left and right pointers along accordingly
    \item Take care to write loops to skip over duplicate values at left, right and i. Avoids TLE.
\end{itemize}

\subsection{73. Set Matrix Zeroes}
\href{https://leetcode.com/problems/set-matrix-zeroes/}{Link to question},
\href{https://leetcode.com/submissions/detail/335922950/}{Link to submission}
\paragraph{Concepts}
Space Optimization, In Place
\paragraph{Algorithm description}
\begin{itemize}
    \item Set boolean variables to decide if first row and first column need setting to zero
    \item Traverse matrix (excluding first row and first column)
    \item Wherever arr[i][j] == 0, set arr[i][0] and arr[0][j] as 0
    \item Traverse matrix (excluding first row and first column). If arr[i][0] == 0 or arr[0][j] == 0, set arr[i][j] = 0
    \item Finally, set first row and first column as zero if needed, as decided in first step
\end{itemize}

\subsection{49. Group Anagrams}
\href{https://leetcode.com/problems/group-anagrams/}{Link to question},
\href{https://leetcode.com/submissions/detail/335928725/}{Link to submission}
\paragraph{Concepts}
Sorting, Hashtable
\paragraph{Algorithm description}
\begin{itemize}
    \item Set up a map of string, vector<string>
    \item Traverse array
    \item For a string, sort it, and append original string to vector at hashed value of sorted string
    \item Finally, append all vectors to an answer array and return the array
\end{itemize}

\subsection{3. Longest Substring Without Repeating Characters}
\href{https://leetcode.com/problems/longest-substring-without-repeating-characters/}{Link to question},
\href{https://leetcode.com/submissions/detail/336804625/}{Link to submission}
\paragraph{Concepts}
Sliding Window, HashMap, Two Pointer
\paragraph{Algorithm description}
\begin{itemize}
    \item Initialize left and right both at 0
    \item Advance right as you keep getting characters and store their indexes in a map. Keep updating maxLen as max(maxLen, r - l + 1)
    \item The moment you get a repeated character, delete all entries in the map for characters from left ptr to first occurence of repeated character.
    \item Then, update position of left to one index after the first occurence of repeated character, as well as update the first occurence of repeated character as the right pointer.
    \item Return maxLen
\end{itemize}

\subsection{5. Longest Palindromic Substring}
\href{https://leetcode.com/problems/longest-palindromic-substring/}{Link to question},
\href{https://leetcode.com/submissions/detail/337683777/}{Link to submission},
\href{https://leetcode.com/submissions/detail/337711978/}{Link to DP submission}
\paragraph{Concepts}
DP, Two Pointer, Implementation Heavy
\paragraph{Approach 1 description}
\begin{itemize}
    \item Start at each of the 2 * len - 1 possible centres of the string.
    \item Keep expanding outside until palindrome.
    \item Store longest palindrome in answer and return answer
\end{itemize}
\paragraph{DP description}
\begin{itemize}
    \item dp[i][i] = true, dp[i][i+1] = true if s[i] == s[i+1]
    \item dp[i][j] = true if dp[i+1][j-1] == true and s[i] == s[j]
    \item Finally return s.substr(starting index, maxLength)
    \item Do look at implementation to see how dp array is filled. Order is not top to bottom, left to right. It is filled in a diamond shaped manner. Remember DAA course? That way.
\end{itemize}

\subsection{334. Increasing Triplet Subsequence}
\href{https://leetcode.com/problems/increasing-triplet-subsequence/}{Link to question},
\href{https://leetcode.com/submissions/detail/328930482/}{Link to submission}
\paragraph{Concepts}
If-Else
\paragraph{Algorithm description}
\begin{itemize}
    \item Keep a smallest and a second smallest, both initialized at INT MAX
    \item Traverse the array
    \item If number less than equal to smallest, update smallest
    \item Else if number less than equal to second smallest, update second smallest
    \item Else return true
\end{itemize}

\subsection{163. Missing Ranges}
\href{https://leetcode.com/problems/missing-ranges/}{Link to question},
\href{https://leetcode.com/submissions/detail/337760992/}{Link to submission}
\paragraph{Concepts}
Arrays, Implementation
\paragraph{Algorithm description}
\begin{itemize}
    \item Create a new long datatype vector out of integers of nums
    \item Push lower - 1 and upper + 1 to long vector
    \item Generate a differences array 
    \item If difference < 2, continue
    \item If difference equals 2, push back longarray[i]+1 to answer
    \item Else push back (longarray[i]+1)->(longarray[i+1] - 1) to answer
    \item Return answer
\end{itemize}

\section{Linked List}
Link: \href{https://leetcode.com/explore/interview/card/top-interview-questions-medium/107/linked-list/}{Linked List}

\subsection{2. Add Two Numbers}
\href{https://leetcode.com/problems/add-two-numbers/}{Link to question},
\href{https://leetcode.com/submissions/detail/337941956/}{Link to submission}
\paragraph{Concepts}
Linked List
\paragraph{Algorithm description}
\begin{itemize}
    \item Recursive algorithm, construct new node as sum of l1, l2 and carry.
    \item Let next of new node be answer to recursion call for l1.next, l2.next and new carry.
    \item Return new node
\end{itemize}

\subsection{328. Odd Even Linked List}
\href{https://leetcode.com/problems/odd-even-linked-list/}{Link to question},
\href{https://leetcode.com/submissions/detail/337950330/}{Link to submission}
\paragraph{Concepts}
Linked List Manipulation
\paragraph{Algorithm description}
\begin{itemize}
    \item Maintain a current pointer. Set curr.next as curr.next.next. Advance the current pointer.
    \item Finally link the end of the odd list to the start of the even list.
\end{itemize}

\subsection{160. Intersection of Two Linked Lists}
\href{https://leetcode.com/problems/intersection-of-two-linked-lists/}{Link to question},
\href{https://leetcode.com/submissions/detail/329638899/}{Link to approach 1},
\href{https://leetcode.com/submissions/detail/337973211/}{Link to approach 2}
\paragraph{Concepts}
Two pointers, modulus, Smart
\paragraph{Approach 1 description}
\begin{itemize}
    \item Push the pointer for the larger list forward by x times where x is difference between length of larger and smaller lists.
    \item Then, while pointer 1 doesn't equal pointer 2, keep advancing both.
    \item Return pointer 1
\end{itemize}
\paragraph{Approach 2 description}
\begin{itemize}
    \item Keep advancing both pointers. If either one reaches the end, shift it to start of other's head and save the last node of the list.
    \item If they ever match, return the match. Else if their last nodes are both not NULL but different, return NULL (Means no intersection at all).
\end{itemize}

\section{Trees and Graphs}
Link: \href{https://leetcode.com/explore/interview/card/top-interview-questions-medium/108/trees-and-graphs/}{Trees and Graphs}

\subsection{94. Binary Tree Inorder Traversal}
\href{https://leetcode.com/problems/binary-tree-inorder-traversal/}{Link to question},
\href{https://leetcode.com/submissions/detail/338200298/}{Link to iterative submission},
\href{https://leetcode.com/submissions/detail/338194239/}{Link to recursive submission}.
\paragraph{Concepts}
Stack, Tree, Inorder
\paragraph{Iterative Algorithm description}
\begin{itemize}
    \item Recursive is trivial. Left, Middle, Right.
    \item For iterative, before starting while loop, keep pushing root into stack, and setting root as root.left
    \item Now, inside the while loop, pop the top. Push back top to inorder vector. If top.right, exists, keep pushing top.right to stack and setting top.right to it's left subtree.
\end{itemize}

\subsection{103. Binary Tree Zigzag Level Order Traversal}
\href{https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/}{Link to question},
\href{https://leetcode.com/submissions/detail/338220725/}{Link to submission}
\paragraph{Concepts}
Queue, Level Order Traversal
\paragraph{Algorithm description}
\begin{itemize}
    \item Same as a level order traversal, just flip each alternate level before adding to answer array
\end{itemize}

\subsection{105. Construct Binary Tree from Preorder and Inorder Traversal}
\href{https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/}{Link to question},
\href{https://leetcode.com/submissions/detail/338231098/}{Link to submission}
\paragraph{Concepts}
Inorder, Preorder, Recursion, Implementation Heavy
\paragraph{Algorithm description}
\begin{itemize}
    \item Construct a mapping of ele:index in inorder arrays
    \item Recursively construct the binary tree using helper(inorder, preorder, left index, right index, mapping)
    \item If left > right, return NULL
    \item Else, construct node with value as preorder[0]
    \item Pop front of preorder
    \item node.left is helper(inorder, preorder, left index, mapping[node.value] - 1, mapping)
    \item node.right is helper(inorder, preorder, mapping[node.value] + 1, right index, mapping)
    \item return node
\end{itemize}

\subsection{116. Populating Next Right Pointers in Each Node}
\href{https://leetcode.com/problems/populating-next-right-pointers-in-each-node/}{Link to question},
\href{https://leetcode.com/submissions/detail/338234563/}{Link to level order submission},
\href{https://leetcode.com/submissions/detail/338238274/}{Link to recursive submission},
\href{https://leetcode.com/submissions/detail/338241582/}{Link to iterative submission}.
\paragraph{Concepts}
Level Order Traversal, Recursion
\paragraph{Level Order Algorithm description}
\begin{itemize}
    \item Go via a level order traversal
    \item For each level, link (i)th node.next = (i+1)th node
\end{itemize}
\paragraph{Recursive Algorithm description}
\begin{itemize}
    \item Top down approach
    \item Assume you're at a level i, and the i-1th has next links established. You have the leftmost node at ith level, and it's parent at i-1th level.
    \item Set current node = leftmost node. If current node is a left node, set next as right node of parent. If current node is a right node, set next as left node of next of parent.
    \item Advance current, and parent nodes accordingly.
    \item Finally, call function for (leftmost.left, leftmost)
    \item Return leftmost
\end{itemize}
\paragraph{Iterative Algorithm description}
\begin{itemize}
    \item Same algorithm as above, you just form linkages for i+1th level, while having already established linkages for the ith level which you are on.
    \item Set leftmost node to root. While leftmost.left != NULL, proceed as follows
    \item Set curr = leftmost. Set curr.left.next as curr.right. Set curr.right.next = curr.next.left. Keep advancing curr.
    \item Set leftmost = leftmost.left
    \item Finally, return root
\end{itemize}

\subsection{230. Kth Smallest Element in a BST}
\href{https://leetcode.com/problems/kth-smallest-element-in-a-bst/}{Link to question},
\href{https://leetcode.com/submissions/detail/329744905/}{Link to approach 1},
\href{https://leetcode.com/submissions/detail/338352974/}{Link to approach 2}.
\paragraph{Concepts}
Inorder
\paragraph{Approach 1 description}
\begin{itemize}
    \item Find inorder array
    \item Return inorder[k-1]
\end{itemize}
\paragraph{Approach 2 description}
\begin{itemize}
    \item Traverse tree inorder. Once you visit k nodes, return value at current node.
\end{itemize}

\subsection{285. Inorder Successor in BST}
\href{https://leetcode.com/problems/inorder-successor-in-bst/}{Link to question},
\href{https://leetcode.com/submissions/detail/329750456/}{Link to approach 1},
\href{https://leetcode.com/submissions/detail/338358126/}{Link to approach 2}.
\paragraph{Concepts}
Inorder
\paragraph{Approach 1 description}
\begin{itemize}
    \item Find inorder array
    \item Return node that is next in line after node to be searched for
\end{itemize}
\paragraph{Approach 2 description}
\begin{itemize}
    \item Traverse tree inorder. Once you reach node to be searched for, return the very next node you find.
\end{itemize}

\subsection{200. Number of Islands}
\href{https://leetcode.com/problems/number-of-islands/}{Link to question},
\href{https://leetcode.com/submissions/detail/338367817/}{Link to DFS submission}
\href{https://leetcode.com/submissions/detail/330130757/}{Link to BFS submission}.
\paragraph{Concepts}
BFS / DFS
\paragraph{Algorithm description}
\begin{itemize}
    \item Simple problem of finding connected components in a graph
    \item Use either BFS or DFS
\end{itemize}

% \subsection{}
% \href{}{Link to question},
% \href{}{Link to submission}
% \paragraph{Concepts}

% \paragraph{Algorithm description}
% \begin{itemize}
%     \item 
% \end{itemize}

\end{document}
